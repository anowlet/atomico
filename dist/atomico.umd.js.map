{"version":3,"file":"atomico.umd.js","sources":["../src/diff/constants.js","../src/diff/dom.js","../src/diff/vdom.js","../src/diff/diff.js","../src/utils.js","../src/index.js"],"sourcesContent":["export const ELEMENT_PREFIX = \"element-\";\r\nexport const ELEMENT_COLLECT = ELEMENT_PREFIX + \"collect\";\r\nexport const ELEMENT_MASTER = ELEMENT_PREFIX + \"master\";\r\nexport const ELEMENT_CONTEXT = ELEMENT_PREFIX + \"context\";\r\n","export function root(parent) {\r\n    return parent.shadowRoot || parent;\r\n}\r\nexport function remove(parent, child) {\r\n    root(parent).removeChild(child);\r\n}\r\n\r\nexport function append(parent, child) {\r\n    root(parent).appendChild(child);\r\n}\r\n\r\nexport function replace(parent, newChild, oldChild) {\r\n    root(parent).replaceChild(newChild, oldChild);\r\n}\r\n","/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n * @return {VDom}\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return new VDom(tag, props, concat(children));\r\n}\r\n/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n */\r\n\r\nexport class VDom {\r\n    constructor(tag, props, children) {\r\n        this.tag = tag;\r\n        this.props = props || {};\r\n        this.children = children || [];\r\n    }\r\n    clone(tag = this.tag, props = this.props, children = this.children) {\r\n        return new VDom(tag, { ...props }, children);\r\n    }\r\n}\r\nexport function isDom(tag) {\r\n    return tag !== null && typeof tag === \"object\" && tag.nodeType !== 11\r\n        ? true\r\n        : false;\r\n}\r\n/**\r\n *\r\n * @param {*} value\r\n * @return {Boolean}\r\n */\r\nexport function isVDom(value) {\r\n    return typeof value === \"object\" && value instanceof VDom;\r\n}\r\n/**\r\n * prepares the children associated with virtual dom, managing to simplify the algorithm of diff\r\n * @param {*} children - list of children associated with the virtual dom\r\n * @param {*} merge - array that concatenates all the children independent of the depth of the array\r\n * @return {Array}\r\n */\r\nexport function concat(children, merge = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let child = children[i];\r\n        Array.isArray(child)\r\n            ? concat(child, merge)\r\n            : merge.push(\r\n                  isVDom(child) ? child : new VDom(\"\", {}, [child || \"\"])\r\n              );\r\n    }\r\n    return merge;\r\n}\r\n","import { ELEMENT_MASTER, ELEMENT_COLLECT, ELEMENT_CONTEXT } from \"./constants\";\r\nimport { remove, append, replace, root } from \"./dom\";\r\nimport { VDom, h, isDom } from \"./vdom\";\r\n/**\r\n * Analyze if prev Node has or does not have a state defined by the diff process,\r\n * this is left linked to the node to avoid its loss either by external editing.\r\n *\r\n * @param {HTMLELement} [parent] - If the father is defined, the remove function is activated,\r\n *                                 it allows to remove the nodes from the father\r\n * @param {HTMLELement} [prevNode] - Node that can possess the previous state\r\n * @param {Object} next - Next render state\r\n * @param {Object} slots - Group the slots to be retrieved by the special slot tag\r\n * @param {*} context - allows to share information within the children of the component\r\n * @param {Boolean} svg - define if the html element is a svg\r\n * @return {HTMLELement} - returns the current node.\r\n */\r\nexport function diff(parent, prevNode, next, slots = {}, context, isSvg) {\r\n    let branch = (prevNode && prevNode[ELEMENT_MASTER]) || new Map(),\r\n        prev = branch.get(parent) || new VDom(),\r\n        nextNode = prevNode,\r\n        nextMaster = next;\r\n\r\n    let isSlot = next.tag === \"slot\";\r\n\r\n    next = slot(next, slots);\r\n    prev = slot(prev, slots);\r\n\r\n    isSvg = isSvg || next.tag === \"svg\";\r\n\r\n    if (parent) {\r\n        if (prev.tag !== next.tag) {\r\n            nextNode = isDom(next.tag)\r\n                ? next.tag\r\n                : next.tag\r\n                ? isSvg\r\n                    ? document.createElementNS(\r\n                          \"http://www.w3.org/2000/svg\",\r\n                          next.tag\r\n                      )\r\n                    : document.createElement(next.tag)\r\n                : document.createTextNode(\"\");\r\n            if (prevNode) {\r\n                replace(parent, nextNode, prevNode);\r\n                let length = next.children.length;\r\n                while (!isSlot && !next.collect && prevNode.firstChild) {\r\n                    if (length--) return;\r\n                    append(nextNode, prevNode.firstChild);\r\n                }\r\n            } else {\r\n                append(parent, nextNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!next.tag) {\r\n        if (prev.children[0] !== next.children[0])\r\n            nextNode.textContent = next.children[0];\r\n    } else {\r\n        if (nextNode && nextNode[ELEMENT_CONTEXT]) {\r\n            context = nextNode[ELEMENT_CONTEXT](context);\r\n        }\r\n        let collect = (parent && nextNode[ELEMENT_COLLECT]) || {},\r\n            props = diffProps(\r\n                nextNode,\r\n                next.tag === prev.tag ? prev.props : {},\r\n                next.props,\r\n                isSvg,\r\n                /**\r\n                 * It allows to obtain properties of the iteration of diff by properties\r\n                 */\r\n                collect.props\r\n            );\r\n        if (collect.handler) {\r\n            props.children = next.children.map(vdom =>\r\n                vdom.tag ? vdom : vdom.children[0]\r\n            );\r\n            collect.handler(props);\r\n        } else {\r\n            if (!isSlot && nextNode) {\r\n                let childNodes = Array.from(root(nextNode).childNodes),\r\n                    children = next.children,\r\n                    length = Math.max(children.length, next.children.length);\r\n                for (let i = 0; i < length; i++) {\r\n                    if (children[i]) {\r\n                        diff(\r\n                            nextNode,\r\n                            childNodes[i],\r\n                            children[i],\r\n                            slots,\r\n                            context,\r\n                            isSvg\r\n                        );\r\n                        continue;\r\n                    }\r\n                    if (childNodes[i]) {\r\n                        remove(parent, childNodes[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    nextNode[ELEMENT_MASTER] = branch.set(parent, nextMaster);\r\n    return nextNode;\r\n}\r\n\r\nexport function Collect(node, props, handler) {\r\n    this.observer = node[ELEMENT_COLLECT] = { props, handler };\r\n}\r\n\r\nexport function Context(node, handler, prop = \"context\") {\r\n    node[ELEMENT_CONTEXT] = context => {\r\n        return (node[prop] = handler(context) || context);\r\n    };\r\n}\r\n\r\n/**\r\n * compares the attributes associated with the 2 render states\r\n * @param {HTMLELement} node\r\n * @param {Object} prev - properties that the node already has\r\n * @param {Object} next - object with the new properties to define the node\r\n * @param {Boolean} [svg] - define if the html element is a svg\r\n * @param {Object} [collect] -It allows to recover properties, avoiding in turn the analysis\r\n *                            of these on the node, these are returned in an object in association\r\n *                            with the key of the loop\r\n * @param {Boolean} [nextMerge] - it allows not to eliminate the properties of the previous state and add them to the next state\r\n * @return {Object} Collected properties\r\n */\r\nfunction diffProps(node, prev, next, isSvg, collect) {\r\n    // generates a list of the existing attributes in both versions\r\n    let keys = Object.keys(prev).concat(Object.keys(next)),\r\n        length = keys.length,\r\n        props = {};\r\n    for (let i = 0; i < length; i++) {\r\n        let prop = keys[i];\r\n\r\n        if (isSvg && prop === \"xmlns\") continue;\r\n        if (prev[prop] !== next[prop]) {\r\n            if (collect && collect.indexOf(prop) > -1) {\r\n                props[prop] = next[prop];\r\n                continue;\r\n            }\r\n\r\n            let isFnNext = typeof next[prop] === \"function\",\r\n                isFnPrev = typeof prev[prop] === \"function\";\r\n\r\n            if (isFnNext || isFnPrev) {\r\n                if (isFnPrev) node.removeEventListener(prop, prev[prop]);\r\n                if (isFnNext) node.addEventListener(prop, next[prop]);\r\n            } else if (prop in next) {\r\n                if ((prop in node && !isSvg) || (isSvg && prop === \"style\")) {\r\n                    if (prop === \"style\") {\r\n                        if (typeof next[prop] === \"object\") {\r\n                            let prevStyle = prev[prop] || {},\r\n                                nextStyle = next[prop];\r\n                            for (let prop in nextStyle) {\r\n                                if (prevStyle[prop] !== nextStyle[prop]) {\r\n                                    if (prop[0] === \"-\") {\r\n                                        node.setProperty(prop, nextStyle[prop]);\r\n                                    } else {\r\n                                        node.style[prop] = nextStyle[prop];\r\n                                    }\r\n                                }\r\n                            }\r\n                            next[prop] = { ...prevStyle, ...nextStyle };\r\n                        } else {\r\n                            node.style.cssText = next[prop];\r\n                        }\r\n                    } else {\r\n                        node[prop] = next[prop];\r\n                    }\r\n                } else {\r\n                    isSvg\r\n                        ? node.setAttributeNS(null, prop, next[prop])\r\n                        : node.setAttribute(prop, next[prop]);\r\n                }\r\n            } else {\r\n                if (collect) {\r\n                    next[prop] = prev[prop];\r\n                } else {\r\n                    node.removeAttribute(prop);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return props;\r\n}\r\n/**\r\n *\r\n * @param {VDom} vdom - It allows to identify if this node requires the use of a slot\r\n * @param {Object} slots - Object that has living nodes associated by an index\r\n */\r\nfunction slot(vdom, slots) {\r\n    if (vdom.tag === \"slot\") {\r\n        vdom = vdom.clone(slots[vdom.props.name] || \"\");\r\n        delete vdom.props.name;\r\n        return vdom;\r\n    }\r\n    return vdom;\r\n}\r\n","export function camelCase(string) {\r\n    return string.replace(/-+([\\w])/g, (all, letter) => letter.toUpperCase());\r\n}\r\n\r\nexport function defer(handler) {\r\n    return Promise.resolve().then(handler);\r\n}\r\n\r\nexport function getProps(props) {\r\n    let isArray = Array.isArray(props);\r\n    return {\r\n        keys: (isArray ? props : Object.keys(props)).concat(\"children\"),\r\n        types: isArray ? {} : props\r\n    };\r\n}\r\n","import { h, diff, isVDom, Collect, Context } from \"./diff\";\r\nimport { getProps, defer, camelCase } from \"./utils\";\r\n\r\nexport { h } from \"./diff\";\r\n\r\nexport class Element extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        this.props = {};\r\n        this.slots = {};\r\n        this.state = {};\r\n        this.preventRender = true;\r\n        this.is = this.nodeName.toLocaleLowerCase();\r\n        this._props = getProps(this.constructor.props);\r\n        new Collect(this, this._props.keys, props => this.setProperties(props));\r\n        new Context(this, context => this.getContext(context));\r\n    }\r\n    get content() {\r\n        return this.shadowRoot || this;\r\n    }\r\n    static get props() {\r\n        return [];\r\n    }\r\n    static get observedAttributes() {\r\n        return getProps(this.props).keys;\r\n    }\r\n    setAttribute(prop, value) {\r\n        if (this._props.keys.indexOf(prop) > -1) {\r\n            this.setProperties({ [prop]: value });\r\n        } else {\r\n            super.setAttribute(prop, value);\r\n        }\r\n    }\r\n    setProperties(props) {\r\n        let nextProps = {},\r\n            prevent = this.isMounted;\r\n        for (let prop in props) {\r\n            let type = this._props.types[prop],\r\n                value = props[prop],\r\n                index;\r\n            value = type ? type(value) : value;\r\n            index = camelCase(prop);\r\n            if (value !== this.props[index]) {\r\n                nextProps[index] = value;\r\n            }\r\n        }\r\n        if (Object.keys(nextProps).length) {\r\n            if (prevent) prevent = this.onUpdate(nextProps) !== false;\r\n            this.props = { ...this.props, ...nextProps };\r\n            if (prevent) this.setState({});\r\n        }\r\n    }\r\n    setState(state, watch) {\r\n        if (typeof state !== \"object\") return;\r\n        this.state = { ...this.state, ...state };\r\n        if (this.preventRender) return;\r\n        this.preventRender = true;\r\n        defer(() => {\r\n            let render = this.render();\r\n            render =\r\n                isVDom(render) && render.tag === \"host\"\r\n                    ? render\r\n                    : h(\"host\", {}, render);\r\n\r\n            diff(false, this, render.clone(this.is), this.slots, this.context);\r\n            this.preventRender = false;\r\n            watch ? watch() : this.onUpdated();\r\n        });\r\n    }\r\n    connectedCallback() {\r\n        defer(() => {\r\n            let fragment = document.createDocumentFragment();\r\n            while (this.firstChild) {\r\n                let child = this.firstChild,\r\n                    slot = child.getAttribute && child.getAttribute(\"slot\");\r\n                if (slot) {\r\n                    this.slots[slot] = child;\r\n                }\r\n                fragment.appendChild(child);\r\n            }\r\n            this.preventRender = false;\r\n            this.setState({}, () => {\r\n                this.isMounted = true;\r\n                this.onMounted();\r\n            });\r\n        });\r\n    }\r\n    disconnectedCallback() {\r\n        this.onUnmounted();\r\n    }\r\n    attributeChangedCallback(index, prev, next) {\r\n        if (prev !== next) this.setProperties({ [index]: next });\r\n    }\r\n    dispatch(type, detail) {\r\n        this.dispatchEvent(new CustomEvent(type, { detail }));\r\n    }\r\n    getContext() {}\r\n    onMounted() {}\r\n    onUpdate() {}\r\n    onUnmounted() {}\r\n    onUpdated() {}\r\n    render() {}\r\n}\r\n"],"names":["ELEMENT_COLLECT","ELEMENT_PREFIX","ELEMENT_MASTER","ELEMENT_CONTEXT","root","parent","shadowRoot","remove","child","removeChild","append","appendChild","h","tag","props","children","VDom","concat","merge","i","length","Array","isArray","push","isVDom","constructor","clone","this","value","diff","prevNode","next","slots","context","isSvg","branch","Map","prev","get","nextNode","nextMaster","isSlot","slot","nodeType","document","createElementNS","createElement","createTextNode","newChild","oldChild","replaceChild","replace","collect","firstChild","node","keys","Object","prop","indexOf","isFnNext","isFnPrev","removeEventListener","addEventListener","prevStyle","nextStyle","setProperty","style","cssText","setAttributeNS","setAttribute","removeAttribute","diffProps","handler","map","vdom","childNodes","from","Math","max","textContent","set","Collect","observer","Context","name","defer","Promise","resolve","then","getProps","types","HTMLElement","state","preventRender","is","nodeName","toLocaleLowerCase","_props","setProperties","getContext","nextProps","prevent","isMounted","index","type","all","letter","toUpperCase","onUpdate","setState","watch","render","onUpdated","connectedCallback","fragment","createDocumentFragment","getAttribute","onMounted","disconnectedCallback","onUnmounted","attributeChangedCallback","dispatch","detail","dispatchEvent","CustomEvent"],"mappings":"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"}