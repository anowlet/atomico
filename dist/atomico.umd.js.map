{"version":3,"file":"atomico.umd.js","sources":["../src/diff/dom.js","../src/diff/vdom.js","../src/diff/diff.js","../src/index.js"],"sourcesContent":["export function remove(parent, child) {\r\n    parent.removeChild(child);\r\n}\r\n\r\nexport function append(parent, child) {\r\n    parent.appendChild(child);\r\n}\r\n\r\nexport function replace(parent, newChild, oldChild) {\r\n    parent.replaceChild(newChild, oldChild);\r\n}\r\n\r\nexport function create(tag, isSvg) {\r\n    return isSvg\r\n        ? document.createElementNS(\"http://www.w3.org/2000/svg\", tag)\r\n        : tag\r\n        ? document.createElement(tag)\r\n        : document.createTextNode(\"\");\r\n}\r\n","/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n * @return {VDom}\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return new VDom(tag, props, concat(children));\r\n}\r\n/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n */\r\n\r\nexport class VDom {\r\n    constructor(tag, props, children) {\r\n        this.tag = tag;\r\n        this.props = props || {};\r\n        this.children = children || [];\r\n    }\r\n    clone(tag = this.tag, props = this.props, children = this.children) {\r\n        return new VDom(tag, { ...props }, children);\r\n    }\r\n}\r\n/**\r\n *\r\n * @param {*} value\r\n * @return {Boolean}\r\n */\r\nexport function isVDom(value) {\r\n    return value instanceof VDom;\r\n}\r\n/**\r\n * prepares the children associated with virtual dom, managing to simplify the algorithm of diff\r\n * @param {*} children - list of children associated with the virtual dom\r\n * @param {*} merge - array that concatenates all the children independent of the depth of the array\r\n * @return {Array}\r\n */\r\nexport function concat(children, next = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let value = children[i];\r\n        Array.isArray(value) ? concat(value, next) : next.push(value);\r\n    }\r\n    return next;\r\n}\r\n","import { remove, append, replace, create } from \"./dom\";\r\nimport { VDom, h, isVDom } from \"./vdom\";\r\n\r\nexport let PREVIOUS = \"__PREVIOUS__\";\r\nexport let LISTENERS = \"__LISTENERS__\";\r\n\r\nexport function createRender(root) {\r\n    let localName = root.tagName.toLowerCase();\r\n    root[PREVIOUS] = h(localName);\r\n    return next => {\r\n        if (isVDom(next) && next.tag === \"host\") {\r\n            next = next.clone(localName);\r\n        } else {\r\n            next = h(localName, {}, next);\r\n        }\r\n        diff(root, root, root, next);\r\n    };\r\n}\r\n/**\r\n * Analyze if prev Node has or does not have a state defined by the diff process,\r\n * this is left linked to the node to avoid its loss either by external editing.\r\n *\r\n * @param {HTMLELement} [parent] - If the father is defined, the remove function is activated,\r\n *                                 it allows to remove the nodes from the father\r\n * @param {HTMLELement} [prevNode] - Node that can possess the previous state\r\n * @param {Object} next - Next render state\r\n * @param {Object} slots - Group the slots to be retrieved by the special slot tag\r\n * @param {*} context - allows to share information within the children of the component\r\n * @param {Boolean} svg - define if the html element is a svg\r\n * @return {HTMLELement} - returns the current node.\r\n */\r\n\r\nexport function diff(root, parent, node, next, isSvg, deep) {\r\n    let prev = (node && node[PREVIOUS]) || new VDom(),\r\n        base = node;\r\n\r\n    if (next && typeof next.tag === \"function\") {\r\n        next = next.tag({ ...next.props, children: next.children });\r\n    }\r\n\r\n    if (!(next instanceof VDom)) {\r\n        next = new VDom(\"\", {}, next);\r\n    }\r\n\r\n    if (prev.tag !== next.tag) {\r\n        base = create(next.tag, isSvg);\r\n        if (node) {\r\n            if (next.tag !== \"\") {\r\n                let length = next.children.length;\r\n                while (node.firstChild) {\r\n                    if (!length--) break;\r\n                    append(base, node.firstChild);\r\n                }\r\n            }\r\n            replace(parent, base, node);\r\n        } else {\r\n            append(parent, base);\r\n        }\r\n    }\r\n    if (next.tag) {\r\n        diffProps(\r\n            base,\r\n            prev.tag === next.tag ? prev.props : {},\r\n            next.props,\r\n            isSvg\r\n        );\r\n        if (next.tag === \"slot\") {\r\n            let name = next.props.name;\r\n        } else {\r\n            let nextBase = deep ? base : base.shadowRoot || base,\r\n                childNodes = nextBase.childNodes,\r\n                children = next.children,\r\n                move = 0,\r\n                length = Math.max(children.length, childNodes.length);\r\n            for (let i = 0; i < length; i++) {\r\n                let childI = i - move;\r\n                if (i in children) {\r\n                    diff(\r\n                        root,\r\n                        nextBase,\r\n                        childNodes[childI],\r\n                        children[i],\r\n                        isSvg,\r\n                        deep + 1\r\n                    );\r\n                } else {\r\n                    remove(nextBase, childNodes[childI]);\r\n                    move++;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        if (prev.children !== next.children) {\r\n            base.textContent = next.children;\r\n        }\r\n    }\r\n    base[PREVIOUS] = next;\r\n    return base;\r\n}\r\n\r\n/**\r\n * compares the attributes associated with the 2 render states\r\n * @param {HTMLELement} node\r\n * @param {Object} prev - properties that the node already has\r\n * @param {Object} next - object with the new properties to define the node\r\n * @param {Boolean} [svg] - define if the html element is a svg\r\n * @param {Object} [collect] -It allows to recover properties, avoiding in turn the analysis\r\n *                            of these on the node, these are returned in an object in association\r\n *                            with the key of the loop\r\n * @param {Boolean} [nextMerge] - it allows not to eliminate the properties of the previous state and add them to the next state\r\n * @return {Object} Collected properties\r\n */\r\nfunction diffProps(node, prev, next, isSvg) {\r\n    let prevKeys = Object.keys(prev),\r\n        nextKeys = Object.keys(next),\r\n        keys = prevKeys.concat(nextKeys),\r\n        define = {};\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n        let prop = keys[i];\r\n\r\n        if (define[prop] || prev[prop] === next[prop]) continue;\r\n\r\n        define[prop] = true;\r\n\r\n        let isFnPrev = typeof prev[prop] === \"function\",\r\n            isFnNext = typeof next[prop] === \"function\";\r\n\r\n        if (isFnPrev || isFnNext) {\r\n            if (!isFnNext && isFnPrev) {\r\n                node.removeEventListener(prop, node[LISTENERS][prop][0]);\r\n            }\r\n            if (isFnNext) {\r\n                if (!isFnPrev) {\r\n                    node[LISTENERS] = node[LISTENERS] || {};\r\n                    if (!node[LISTENERS][prop]) {\r\n                        node[LISTENERS][prop] = [\r\n                            event => {\r\n                                node[LISTENERS][prop][1](event);\r\n                            }\r\n                        ];\r\n                    }\r\n                    node.addEventListener(prop, node[LISTENERS][prop][0]);\r\n                }\r\n                node[LISTENERS][prop][1] = next[prop];\r\n            }\r\n        } else if (prop in next) {\r\n            if ((prop in node && !isSvg) || (isSvg && prop === \"style\")) {\r\n                if (prop === \"style\") {\r\n                    if (typeof next[prop] === \"object\") {\r\n                        let prevStyle = prev[prop] || {},\r\n                            nextStyle = next[prop];\r\n                        for (let prop in nextStyle) {\r\n                            if (prevStyle[prop] !== nextStyle[prop]) {\r\n                                if (prop[0] === \"-\") {\r\n                                    node.style.setProperty(\r\n                                        prop,\r\n                                        nextStyle[prop]\r\n                                    );\r\n                                } else {\r\n                                    node.style[prop] = nextStyle[prop];\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        node.style.cssText = next[prop];\r\n                    }\r\n                } else {\r\n                    node[prop] = next[prop];\r\n                }\r\n            } else {\r\n                isSvg\r\n                    ? node.setAttributeNS(null, prop, next[prop])\r\n                    : node.setAttribute(prop, next[prop]);\r\n            }\r\n        } else {\r\n            node.removeAttribute(prop);\r\n        }\r\n    }\r\n}\r\n","import { createRender } from \"./diff\";\r\nexport { h, createRender } from \"./diff\";\r\n\r\nfunction camelCase(string) {\r\n    return string.replace(/-+([\\w])/g, (all, letter) => letter.toUpperCase());\r\n}\r\nfunction unCamelCase(string) {\r\n    return string.replace(\r\n        /([^\\-])([A-Z]+)/,\r\n        (all, before, after) => before + \"-\" + after.toLowerCase()\r\n    );\r\n}\r\n/**\r\n * @param {object|array} props - allows you to generate an object that contains the props to be observed by the component and the type functions\r\n * @return {object}\r\n */\r\nfunction getProps(props) {\r\n    let isArray = Array.isArray(props),\r\n        keys = [],\r\n        types = {};\r\n    for (let key in props) {\r\n        let prop = unCamelCase(isArray ? props[key] : key);\r\n        if (isArray) {\r\n            keys.push(prop);\r\n        } else {\r\n            keys.push(prop);\r\n            types[prop] = props[key];\r\n            types[camelCase(key)] = props[key];\r\n        }\r\n    }\r\n    return {\r\n        keys,\r\n        types\r\n    };\r\n}\r\n\r\nexport class Element extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n\r\n        let render = createRender(this),\r\n            resolve;\r\n\r\n        this.props = {};\r\n        this.countRender = 0;\r\n        this.preventRender = true;\r\n        this.proxy = getProps(this.constructor.props);\r\n\r\n        this.load = () => {\r\n            this.preventRender = false;\r\n            resolve();\r\n        };\r\n\r\n        this.await = new Promise(load => (resolve = load));\r\n\r\n        this.rerender = state => {\r\n            if (this.preventRender) return;\r\n            this.preventRender = true;\r\n            Promise.resolve().then(() => {\r\n                render(this.render());\r\n                this.preventRender = false;\r\n                this.countRender++ ? this.onUpdated() : this.onMounted();\r\n            });\r\n        };\r\n\r\n        this.proxy.keys.forEach(key => {\r\n            key = camelCase(key);\r\n            Object.defineProperty(this, key, {\r\n                set(value) {\r\n                    this.setProps({ [key]: value });\r\n                },\r\n                get() {\r\n                    return this.props[key];\r\n                }\r\n            });\r\n        });\r\n    }\r\n    static get props() {\r\n        return [];\r\n    }\r\n    render() {}\r\n    onMounted() {}\r\n    onUpdated() {}\r\n    onUnmounted() {}\r\n    setProps(props) {\r\n        let nextProps = {},\r\n            nextRender;\r\n        for (let key in props) {\r\n            let prevValue = this.props[key];\r\n            if (props[key] !== prevValue) {\r\n                let type = this.proxy.types[key],\r\n                    nextValue = type ? type(props[key], prevValue) : props[key];\r\n                if (nextValue !== prevValue) {\r\n                    nextProps[key] = nextValue;\r\n                    nextRender = true;\r\n                }\r\n            }\r\n        }\r\n        if (nextRender) {\r\n            this.props = { ...this.props, ...nextProps };\r\n            this.rerender();\r\n        }\r\n    }\r\n    setAttribute(prop, value) {\r\n        if (this.proxy.keys.indexOf(prop) > -1) {\r\n            this.setProps({ [camelCase(prop)]: value });\r\n        } else {\r\n            super.setAttribute(prop, value);\r\n        }\r\n    }\r\n    static get observedAttributes() {\r\n        return getProps(this.props).keys;\r\n    }\r\n    connectedCallback() {\r\n        this.load();\r\n        this.await.then(() => this.rerender());\r\n    }\r\n    disconnectedCallback() {\r\n        this.await.then(() => this.onUnmounted());\r\n    }\r\n    attributeChangedCallback(name, prev, next) {\r\n        this.setProps({ [name]: next });\r\n    }\r\n}\r\n"],"names":["remove","parent","child","removeChild","append","appendChild","h","tag","props","children","VDom","concat","next","i","length","value","Array","isArray","push","constructor","clone","this","PREVIOUS","LISTENERS","createRender","root","localName","tagName","toLowerCase","isVDom","diff","node","isSvg","deep","prev","base","document","createElementNS","createElement","createTextNode","create","firstChild","newChild","oldChild","replaceChild","replace","prevKeys","Object","keys","nextKeys","define","prop","isFnPrev","isFnNext","removeEventListener","event","addEventListener","prevStyle","nextStyle","style","setProperty","cssText","setAttributeNS","setAttribute","removeAttribute","diffProps","name","nextBase","shadowRoot","childNodes","move","Math","max","childI","textContent","camelCase","string","all","letter","toUpperCase","getProps","types","key","before","after","HTMLElement","resolve","render","countRender","preventRender","proxy","load","await","Promise","rerender","state","then","onUpdated","onMounted","forEach","defineProperty","set","setProps","get","onUnmounted","nextRender","nextProps","prevValue","type","nextValue","indexOf","connectedCallback","disconnectedCallback","attributeChangedCallback"],"mappings":"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"}