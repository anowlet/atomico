{"version":3,"file":"atomico.js","sources":["../src/diff/dom.js","../src/diff/vdom.js","../src/diff/diff.js","../src/index.js"],"sourcesContent":["export function remove(parent, child) {\r\n    parent.removeChild(child);\r\n}\r\n\r\nexport function append(parent, child) {\r\n    parent.appendChild(child);\r\n}\r\n\r\nexport function replace(parent, newChild, oldChild) {\r\n    parent.replaceChild(newChild, oldChild);\r\n}\r\n\r\nexport function create(tag, isSvg) {\r\n    return isSvg\r\n        ? document.createElementNS(\"http://www.w3.org/2000/svg\", tag)\r\n        : tag\r\n        ? document.createElement(tag)\r\n        : document.createTextNode(\"\");\r\n}\r\n","/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n * @return {VDom}\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return new VDom(tag, props, concat(children));\r\n}\r\n/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n */\r\n\r\nexport class VDom {\r\n    constructor(tag, props, children) {\r\n        this.tag = tag;\r\n        this.props = props || {};\r\n        this.children = children || [];\r\n    }\r\n    clone(tag = this.tag, props = this.props, children = this.children) {\r\n        return new VDom(tag, { ...props }, children);\r\n    }\r\n}\r\n/**\r\n *\r\n * @param {*} value\r\n * @return {Boolean}\r\n */\r\nexport function isVDom(value) {\r\n    return value instanceof VDom;\r\n}\r\n/**\r\n * prepares the children associated with virtual dom, managing to simplify the algorithm of diff\r\n * @param {*} children - list of children associated with the virtual dom\r\n * @param {*} merge - array that concatenates all the children independent of the depth of the array\r\n * @return {Array}\r\n */\r\nexport function concat(children, next = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let value = children[i];\r\n        Array.isArray(value) ? concat(value, next) : next.push(value);\r\n    }\r\n    return next;\r\n}\r\n","import { remove, append, replace, create } from \"./dom\";\r\nimport { VDom, h, isVDom } from \"./vdom\";\r\n\r\nexport let PREVIOUS = \"__PREVIOUS__\";\r\nexport let LISTENERS = \"__LISTENERS__\";\r\n\r\nexport function createRender(root) {\r\n    let localName = root.tagName.toLowerCase();\r\n    root[PREVIOUS] = h(localName);\r\n    return next => {\r\n        if (isVDom(next) && next.tag === \"host\") {\r\n            next = next.clone(localName);\r\n        } else {\r\n            next = h(localName, {}, next);\r\n        }\r\n        diff(root, root, root, next);\r\n    };\r\n}\r\n/**\r\n * Analyze if prev Node has or does not have a state defined by the diff process,\r\n * this is left linked to the node to avoid its loss either by external editing.\r\n *\r\n * @param {HTMLELement} [parent] - If the father is defined, the remove function is activated,\r\n *                                 it allows to remove the nodes from the father\r\n * @param {HTMLELement} [prevNode] - Node that can possess the previous state\r\n * @param {Object} next - Next render state\r\n * @param {Object} slots - Group the slots to be retrieved by the special slot tag\r\n * @param {*} context - allows to share information within the children of the component\r\n * @param {Boolean} svg - define if the html element is a svg\r\n * @return {HTMLELement} - returns the current node.\r\n */\r\n\r\nexport function diff(root, parent, node, next, isSvg, deep) {\r\n    let prev = (node && node[PREVIOUS]) || new VDom(),\r\n        base = node;\r\n\r\n    if (next && typeof next.tag === \"function\") {\r\n        next = next.tag({ ...next.props, children: next.children });\r\n    }\r\n\r\n    if (!(next instanceof VDom)) {\r\n        next = new VDom(\"\", {}, next);\r\n    }\r\n\r\n    if (prev.tag !== next.tag) {\r\n        base = create(next.tag, isSvg);\r\n        if (node) {\r\n            if (next.tag !== \"\") {\r\n                let length = next.children.length;\r\n                while (node.firstChild) {\r\n                    if (!length--) break;\r\n                    append(base, node.firstChild);\r\n                }\r\n            }\r\n            replace(parent, base, node);\r\n        } else {\r\n            append(parent, base);\r\n        }\r\n    }\r\n    if (next.tag) {\r\n        diffProps(\r\n            base,\r\n            prev.tag === next.tag ? prev.props : {},\r\n            next.props,\r\n            isSvg\r\n        );\r\n        if (next.tag === \"slot\") {\r\n            let name = next.props.name;\r\n        } else {\r\n            let nextBase = deep ? base : base.shadowRoot || base,\r\n                childNodes = nextBase.childNodes,\r\n                children = next.children,\r\n                move = 0,\r\n                length = Math.max(children.length, childNodes.length);\r\n            for (let i = 0; i < length; i++) {\r\n                let childI = i - move;\r\n                if (i in children) {\r\n                    diff(\r\n                        root,\r\n                        nextBase,\r\n                        childNodes[childI],\r\n                        children[i],\r\n                        isSvg,\r\n                        deep + 1\r\n                    );\r\n                } else {\r\n                    remove(nextBase, childNodes[childI]);\r\n                    move++;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        if (prev.children !== next.children) {\r\n            base.textContent = next.children;\r\n        }\r\n    }\r\n    base[PREVIOUS] = next;\r\n    return base;\r\n}\r\n\r\n/**\r\n * compares the attributes associated with the 2 render states\r\n * @param {HTMLELement} node\r\n * @param {Object} prev - properties that the node already has\r\n * @param {Object} next - object with the new properties to define the node\r\n * @param {Boolean} [svg] - define if the html element is a svg\r\n * @param {Object} [collect] -It allows to recover properties, avoiding in turn the analysis\r\n *                            of these on the node, these are returned in an object in association\r\n *                            with the key of the loop\r\n * @param {Boolean} [nextMerge] - it allows not to eliminate the properties of the previous state and add them to the next state\r\n * @return {Object} Collected properties\r\n */\r\nfunction diffProps(node, prev, next, isSvg) {\r\n    let prevKeys = Object.keys(prev),\r\n        nextKeys = Object.keys(next),\r\n        keys = prevKeys.concat(nextKeys),\r\n        define = {};\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n        let prop = keys[i];\r\n\r\n        if (define[prop] || prev[prop] === next[prop]) continue;\r\n\r\n        define[prop] = true;\r\n\r\n        let isFnPrev = typeof prev[prop] === \"function\",\r\n            isFnNext = typeof next[prop] === \"function\";\r\n\r\n        if (isFnPrev || isFnNext) {\r\n            if (!isFnNext && isFnPrev) {\r\n                node.removeEventListener(prop, node[LISTENERS][prop][0]);\r\n            }\r\n            if (isFnNext) {\r\n                if (!isFnPrev) {\r\n                    node[LISTENERS] = node[LISTENERS] || {};\r\n                    if (!node[LISTENERS][prop]) {\r\n                        node[LISTENERS][prop] = [\r\n                            event => {\r\n                                node[LISTENERS][prop][1](event);\r\n                            }\r\n                        ];\r\n                    }\r\n                    node.addEventListener(prop, node[LISTENERS][prop][0]);\r\n                }\r\n                node[LISTENERS][prop][1] = next[prop];\r\n            }\r\n        } else if (prop in next) {\r\n            if ((prop in node && !isSvg) || (isSvg && prop === \"style\")) {\r\n                if (prop === \"style\") {\r\n                    if (typeof next[prop] === \"object\") {\r\n                        let prevStyle = prev[prop] || {},\r\n                            nextStyle = next[prop];\r\n                        for (let prop in nextStyle) {\r\n                            if (prevStyle[prop] !== nextStyle[prop]) {\r\n                                if (prop[0] === \"-\") {\r\n                                    node.style.setProperty(\r\n                                        prop,\r\n                                        nextStyle[prop]\r\n                                    );\r\n                                } else {\r\n                                    node.style[prop] = nextStyle[prop];\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        node.style.cssText = next[prop];\r\n                    }\r\n                } else {\r\n                    node[prop] = next[prop];\r\n                }\r\n            } else {\r\n                isSvg\r\n                    ? node.setAttributeNS(null, prop, next[prop])\r\n                    : node.setAttribute(prop, next[prop]);\r\n            }\r\n        } else {\r\n            node.removeAttribute(prop);\r\n        }\r\n    }\r\n}\r\n","import { createRender } from \"./diff\";\r\nexport { h, createRender } from \"./diff\";\r\n\r\nfunction camelCase(string) {\r\n    return string.replace(/-+([\\w])/g, (all, letter) => letter.toUpperCase());\r\n}\r\nfunction unCamelCase(string) {\r\n    return string.replace(\r\n        /([^\\-])([A-Z]+)/,\r\n        (all, before, after) => before + \"-\" + after.toLowerCase()\r\n    );\r\n}\r\n/**\r\n * @param {object|array} props - allows you to generate an object that contains the props to be observed by the component and the type functions\r\n * @return {object}\r\n */\r\nfunction getProps(props) {\r\n    let isArray = Array.isArray(props),\r\n        keys = [],\r\n        types = {};\r\n    for (let key in props) {\r\n        let prop = unCamelCase(isArray ? props[key] : key);\r\n        if (isArray) {\r\n            keys.push(prop);\r\n        } else {\r\n            keys.push(prop);\r\n            types[prop] = props[key];\r\n            types[camelCase(key)] = props[key];\r\n        }\r\n    }\r\n    return {\r\n        keys,\r\n        types\r\n    };\r\n}\r\n\r\nexport class Element extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n\r\n        let render = createRender(this),\r\n            resolve;\r\n\r\n        this.props = {};\r\n        this.countRender = 0;\r\n        this.preventRender = true;\r\n        this.proxy = getProps(this.constructor.props);\r\n\r\n        this.load = () => {\r\n            this.preventRender = false;\r\n            resolve();\r\n        };\r\n\r\n        this.await = new Promise(load => (resolve = load));\r\n\r\n        this.rerender = state => {\r\n            if (this.preventRender) return;\r\n            this.preventRender = true;\r\n            Promise.resolve().then(() => {\r\n                render(this.render());\r\n                this.preventRender = false;\r\n                this.countRender++ ? this.onUpdated() : this.onMounted();\r\n            });\r\n        };\r\n\r\n        this.proxy.keys.forEach(key => {\r\n            key = camelCase(key);\r\n            Object.defineProperty(this, key, {\r\n                set(value) {\r\n                    this.setProps({ [key]: value });\r\n                },\r\n                get() {\r\n                    return this.props[key];\r\n                }\r\n            });\r\n        });\r\n    }\r\n    static get props() {\r\n        return [];\r\n    }\r\n    render() {}\r\n    onMounted() {}\r\n    onUpdated() {}\r\n    onUnmounted() {}\r\n    setProps(props) {\r\n        let nextProps = {},\r\n            nextRender;\r\n        for (let key in props) {\r\n            let prevValue = this.props[key];\r\n            if (props[key] !== prevValue) {\r\n                let type = this.proxy.types[key],\r\n                    nextValue = type ? type(props[key], prevValue) : props[key];\r\n                if (nextValue !== prevValue) {\r\n                    nextProps[key] = nextValue;\r\n                    nextRender = true;\r\n                }\r\n            }\r\n        }\r\n        if (nextRender) {\r\n            this.props = { ...this.props, ...nextProps };\r\n            this.rerender();\r\n        }\r\n    }\r\n    setAttribute(prop, value) {\r\n        if (this.proxy.keys.indexOf(prop) > -1) {\r\n            this.setProps({ [camelCase(prop)]: value });\r\n        } else {\r\n            super.setAttribute(prop, value);\r\n        }\r\n    }\r\n    static get observedAttributes() {\r\n        return getProps(this.props).keys;\r\n    }\r\n    connectedCallback() {\r\n        this.load();\r\n        this.await.then(() => this.rerender());\r\n    }\r\n    disconnectedCallback() {\r\n        this.await.then(() => this.onUnmounted());\r\n    }\r\n    attributeChangedCallback(name, prev, next) {\r\n        this.setProps({ [name]: next });\r\n    }\r\n}\r\n"],"names":["remove","parent","child","removeChild","append","appendChild","replace","newChild","oldChild","replaceChild","create","tag","isSvg","document","createElementNS","createElement","createTextNode","h","props","children","VDom","concat","constructor","clone","this","isVDom","value","next","i","length","Array","isArray","push","PREVIOUS","LISTENERS","createRender","root","localName","tagName","toLowerCase","diff","node","deep","prev","base","firstChild","diffProps","name","nextBase","shadowRoot","childNodes","move","Math","max","childI","textContent","prevKeys","Object","keys","nextKeys","define","prop","isFnPrev","isFnNext","removeEventListener","event","addEventListener","prevStyle","nextStyle","style","setProperty","cssText","setAttributeNS","setAttribute","removeAttribute","camelCase","string","all","letter","toUpperCase","unCamelCase","before","after","getProps","types","key","Element","HTMLElement","resolve","render","countRender","preventRender","proxy","load","await","Promise","rerender","state","then","onUpdated","onMounted","forEach","defineProperty","set","setProps","get","onUnmounted","nextRender","nextProps","prevValue","type","nextValue","indexOf","connectedCallback","disconnectedCallback","attributeChangedCallback"],"mappings":"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"}